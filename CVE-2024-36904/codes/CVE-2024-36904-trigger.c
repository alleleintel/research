/*
 * This code is property of Allele Security Intelligence (C) and it is distributed as it is.
 *
 * It is intended for educational and research purposes only and we are not liable for
 * any misuse and loss of data resulting from this action.
 *               
 * You may only use and/or modify this content, no redistribution or commercial use is authorized.     
 *                                         
 * Copyright (C) 2024 Allele Security Intelligence < info at allelesecurity dot com >.
 * All rights reserved.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <stdbool.h>
#include <pthread.h>
#include <signal.h>
#include <fcntl.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <netinet/in.h>

#define SERVER_PORT 20000
#define LISTEN_SERVER 10
#define MIN_PORT 1023
#define MAX_PORT 65535

int sport = 0;
pthread_barrier_t barrier[1];
struct sockaddr_in sockaddr_server, sockaddr_client, sockaddr_client_target;
int sk_server, sk_client, sk_server_established, sk_client_target;

void *thread01(void *a){

	printf("[*] - Thread 01 - Waiting for the barrier\n");

	pthread_barrier_wait(&barrier[0]);

	close(sk_server_established);

	printf("[*] - Close executed\n");

return NULL;
}

void *thread02(void *a){
	
	printf("[*] - Thread 02 - Waiting for the barrier\n");

	pthread_barrier_wait(&barrier[0]);

	connect(sk_client_target, (struct sockaddr *)&sockaddr_client_target, sizeof(sockaddr_client_target));

	printf("[*] - Client target socket connect() executed\n");

return NULL;
}

int get_random_source_port(void){
	unsigned char byte[4];
	unsigned int port;
	int fd;

	retry:

		printf("[*] - Opening /dev/urandom\n");

		fd = open("/dev/urandom", O_RDONLY);
		if(fd < 0){
			printf("[!] - Failed to open /dev/urandom\n");
			return -1;
		}

		printf("[*] - Reading from /dev/urandom\n");

		if(read(fd, &byte, sizeof(byte)) < sizeof(byte)){
			printf("[!] - Failed to read from /dev/urandom\n");
			return -1;
		}

		printf("[*] - Closing file descriptor\n");

		close(fd);

		memcpy(&port, &byte, sizeof(port));

		port = (port % MAX_PORT);

		/* If the source port is equal to the destination port, the code gets stuck. */
	        /* If the source port is below MIN_PORT, the code gets a permission error. */

		if(port == SERVER_PORT || port <= MIN_PORT){

			printf("[!] - Random source port %d equal to server port %d or less than %d\n", port, SERVER_PORT, MIN_PORT);
			printf("[!] - Selecting another random source port\n");

			goto retry;
		}

return port;
}

int main(void){
	pthread_t th[2];
	int one = 1;

	setbuf(stdout, NULL);

	memset(&sockaddr_server, '\0', sizeof(sockaddr_server));
	memset(&sockaddr_client, '\0', sizeof(sockaddr_client));
	memset(&sockaddr_client_target, '\0', sizeof(sockaddr_client_target));

	printf("[*] - Creating threads\n");

	if(pthread_barrier_init(&barrier[0], NULL, 3) < 0){
		printf("[!] - Failed to initialize barriers\n");
		exit(EXIT_FAILURE);
	}

	if(pthread_create(&th[0], NULL, thread01, NULL) < 0){
		printf("[!] - Failed to create first thread\n");
		exit(EXIT_FAILURE);
	}

	if(pthread_create(&th[1], NULL, thread02, NULL) < 0){
		printf("[!] - Failed to create second thread\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Threads created\n");
	printf("[*] - Selecting random port\n");

	sport = get_random_source_port();
	if(sport == -1){
		printf("[!] - Failed to select a random port\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Random port: %d\n",sport);

	sk_server = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sk_server < 0){
		printf("[!] - Failed to create a TCP socket for the server\n");
		exit(EXIT_FAILURE);
	}

	sk_client = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sk_client < 0){
		printf("[!] - Failed to create a TCP socket for the client\n");
		exit(EXIT_FAILURE);
	}

	sk_client_target = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if(sk_client_target < 0){
		printf("[!] - Failed to create a TCP socket for the client target\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Sockets created\n");

	printf("[*] - Server socket fd: %d\n", sk_server);
	printf("[*] - Client socket fd: %d\n", sk_client);
	printf("[*] - Client target socket fd: %d\n", sk_client_target);

	printf("[*] - Setting up clients\n");

	printf("[*] - Enabling SO_REUSEPORT on client\n");

	if(setsockopt(sk_client, SOL_SOCKET, SO_REUSEPORT, &one, sizeof(one)) < 0){
		printf("[!] - Failed to enable SO_REUSEPORT on client\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Enabling SO_REUSEPORT on client target\n");

	if(setsockopt(sk_client_target, SOL_SOCKET, SO_REUSEPORT, &one, sizeof(one)) < 0){
		printf("[!] - Failed to enable SO_REUSEPORT on client target\n");
		exit(EXIT_FAILURE);
	}

	sockaddr_server.sin_family = AF_INET;
	sockaddr_server.sin_port = htons(SERVER_PORT);

	inet_pton(AF_INET, "127.0.0.1", &sockaddr_server.sin_addr);

	if(bind(sk_server, (struct sockaddr *)&sockaddr_server, sizeof(sockaddr_server)) < 0){
		printf("[!] - Failed to bind on the server\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Server bound\n");
	printf("[*] - Setting the server to the listen state\n");

	if(listen(sk_server, LISTEN_SERVER) < 0){
		printf("[!] - Failed to set the server to the listen state\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Server listening...\n");
	printf("[*] - Client binding local port\n");

	sockaddr_client.sin_family = AF_INET;
	sockaddr_client.sin_port = htons(sport);
	inet_pton(AF_INET, "127.0.0.1", &sockaddr_client.sin_addr);

	if(bind(sk_client, (struct sockaddr *)&sockaddr_client, sizeof(sockaddr_client)) < 0){
		printf("[!] - Failed to bind on the client\n");
		exit(EXIT_FAILURE);
	}

	sockaddr_client.sin_port = htons(SERVER_PORT);

	printf("[*] - Client connecting to server\n");

	if(connect(sk_client, (struct sockaddr *)&sockaddr_client, sizeof(sockaddr_client)) < 0){
		printf("[!] - Failed to connect to the server\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Client connected\n");
	printf("[*] - Accepting the connection\n");

	if((sk_server_established = accept(sk_server, NULL, NULL)) < 0){
		printf("[!] - Failed to accept the connection\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Established socket fd %d\n", sk_server_established);

	printf("[*] - Shuting down client socket\n");

	if(shutdown(sk_client, SHUT_RDWR) < 0){
		printf("[!] - Failed to shutdown client socket\n");
		exit(EXIT_FAILURE);
	}

	printf("[*] - Binding on client target socket\n");

	sockaddr_client_target.sin_family = AF_INET;
	sockaddr_client_target.sin_port = htons(sport);
	inet_pton(AF_INET, "127.0.0.1", &sockaddr_client_target.sin_addr);

	if(bind(sk_client_target, (struct sockaddr *)&sockaddr_client_target, sizeof(sockaddr_client_target)) < 0){
		printf("[!] - Failed to bind client target\n");
		exit(EXIT_FAILURE);
	}

	sockaddr_client_target.sin_family = AF_INET;
	sockaddr_client_target.sin_port = htons(SERVER_PORT);

	printf("[*] - Releasing barrier\n");
	pthread_barrier_wait(&barrier[0]);

	printf("[*] - Waiting for threads to finish\n");

	if(pthread_join(th[0], NULL) < 0){
		printf("[!] - Error while waiting first thread to exit\n");
	}

	if(pthread_join(th[1], NULL) < 0){
		printf("[!] - Error while waiting second thread to exit\n");
	}

return 0;
}
